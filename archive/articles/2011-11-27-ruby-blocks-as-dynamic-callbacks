<p>Callbacks are a great technique for achieving simplicity and flexibility. Simply put,
a callback is a block of code passed as an argument to a method. In Ruby, code
blocks are everywhere and Ruby makes it trivial to pass a block of code to
methods. For example:</p>
<div class="highlight"><pre class="highlight ruby"><code><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">bar</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="n">callback</span> <span class="o">=</span> <span class="n">block</span>
  <span class="n">callback</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="n">bar</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">foo</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">}</span> <span class="c1"># =&gt; 25</span>
</code></pre></div>
<p>But what do we do when a method needs two blocks of code or more? Consider the
classic case where we want a method to execute a block of code if an action
succeeds or call different code if an action fails.</p>

<p>In this article, I will demonstrate how we can pass multiple blocks to a method and
with some metaprogramming, we can achieve a dynamic callback mechanism with just
a few lines of code.</p>

<p>Let&#39;s add a method called <code>callback</code> to the Proc class:</p>
<div class="highlight"><pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">Proc</span>
  <span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="n">callable</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="nb">self</span> <span class="o">===</span> <span class="no">Class</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
      <span class="n">method_name</span> <span class="o">=</span> <span class="n">callable</span><span class="p">.</span><span class="nf">to_sym</span>
      <span class="n">define_method</span><span class="p">(</span><span class="n">method_name</span><span class="p">)</span> <span class="p">{</span> <span class="o">|&amp;</span><span class="n">block</span><span class="o">|</span> <span class="n">block</span><span class="p">.</span><span class="nf">nil?</span> <span class="p">?</span> <span class="kp">true</span> <span class="p">:</span> <span class="n">block</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="p">}</span>
      <span class="n">define_method</span><span class="p">(</span><span class="s2">"</span><span class="si">#{</span><span class="n">method_name</span><span class="si">}</span><span class="s2">?"</span><span class="p">)</span> <span class="p">{</span> <span class="kp">true</span> <span class="p">}</span>
      <span class="k">def</span> <span class="nf">method_missing</span><span class="p">(</span><span class="n">method_name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span> <span class="kp">false</span><span class="p">;</span> <span class="k">end</span>
    <span class="k">end</span><span class="p">.</span><span class="nf">new</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>That&#39;s it! The above <code>Proc#callback</code> method simply yields an anonymous class
with methods defined to handle our callbacks. This allows for the capability of
creating and storing dynamic callbacks, which can later be looked up and
executed as needed.</p>

<p>Notice anything unusual? We&#39;re using the <code>===</code> operand to invoke the
block. <code>Proc#===</code> is an alias for <code>Proc.call</code>. Anything on the right side of
<code>===</code> acts as the proc&#39;s parameter. Normally, this is to allow a proc object to
be a target of a <code>when</code> clause in case statements, but we&#39;re using it as a super
simple way of invoking our anonymous class.</p>

<p>Let’s try it with something useful. Let’s say we’re writing something which
needs to happen in an all-or-nothing, atomic fashion. Either the whole thing
works, or none of it does.  A simple case is tweeting:</p>
<div class="highlight"><pre class="highlight ruby"><code><span class="k">def</span> <span class="nf">tweet</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="no">Twitter</span><span class="p">.</span><span class="nf">update</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
  <span class="n">block</span><span class="p">.</span><span class="nf">callback</span> <span class="ss">:success</span>
<span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">e</span>
  <span class="n">block</span><span class="p">.</span><span class="nf">callback</span> <span class="ss">:failure</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="nf">message</span>
<span class="k">end</span>
</code></pre></div>
<p>The <code>tweet</code> method accepts a message string and &amp;block parameters. We call
<code>callback</code> on the block and give it a name. Any name will work :success, :error,
:fail!, whatever. In addition, we can pass arguments to the blocks (more on that
later). Now we can provide a status if the tweet was successful or not:</p>
<div class="highlight"><pre class="highlight ruby"><code><span class="n">tweet</span> <span class="s2">"Ruby methods with multiple blocks. #lolruby"</span> <span class="k">do</span> <span class="o">|</span><span class="n">on</span><span class="o">|</span>
  <span class="n">on</span><span class="p">.</span><span class="nf">success</span> <span class="k">do</span>
    <span class="nb">puts</span> <span class="s2">"Tweet successful!"</span>
  <span class="k">end</span>
  <span class="n">on</span><span class="p">.</span><span class="nf">failure</span> <span class="k">do</span> <span class="o">|</span><span class="n">status</span><span class="o">|</span>
    <span class="nb">puts</span> <span class="s2">"Error: </span><span class="si">#{</span><span class="n">status</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>The advantage here is that we define our own mini DSL. We don&#39;t need to worry
about passing too many or unexpected blocks. We could have easily said
<code>where.success</code> or <code>on.error</code> or <code>update.fail!</code>. Also note the <code>on.failure</code>
block includes a <code>status</code> parameter - this contains the exception message
captured in the <code>tweet</code> method above. So if Twitter was down for whatever
reason, the <code>on.failure</code> block would be invoked and printed &#39;Error: Twitter is
down or being upgraded&#39;.</p>

<p>Bonus: In addition to wrapping code in blocks, our <code>Proc#callback</code> method
defines boolean style methods. So we could have call the tweet method like this
if we wanted to:</p>
<div class="highlight"><pre class="highlight ruby"><code><span class="n">tweet</span> <span class="s2">"Ruby methods with multiple blocks. #lolruby"</span> <span class="k">do</span> <span class="o">|</span><span class="n">update</span><span class="o">|</span>
  <span class="nb">puts</span> <span class="s2">"Tweet successful!"</span> <span class="k">if</span> <span class="n">update</span><span class="p">.</span><span class="nf">success?</span>
  <span class="nb">puts</span> <span class="s2">"Sorry, something went wrong."</span> <span class="k">if</span> <span class="n">update</span><span class="p">.</span><span class="nf">failure?</span>
<span class="k">end</span>
</code></pre></div>
<p>Put the <code>Proc#callback</code> method in a utility library and your code will look neat and tidy.</p>

<p>As always, I welcome your thoughts and feedback. Let me know what you think of
the techniques shown here, or share your own favorite code block tricks.</p>
